# MSC2 Clojure Port – Handoff

## Project Snapshot

- **Goal:** Clojure reimplementation of the MSC2 (Minimal Sensorimotor Component 2) kernel with behavior parity to the C reference under `external/msc2`.
- **Current Capabilities**
  - Full reducer pipeline (`core`, FIFO, induction, decision, attention) with shell output that mirrors the C `NAR shell`.
  - Native binary workflow (`scripts/build_native.sh`) producing `target/NAR` via GraalVM so `.nal` macros can be run like `./NAR shell`.
  - Experiment 1 driver (`msc2.experiments.exp1`) that replicates the Python script: baseline, training, and testing phases with CSV logs.
  - Integration tests covering micro `.nal` scripts and the experiment runner.

## Open Issues / Next Steps

1. **Experiment 1 learning gap** – the training phase in `msc2.experiments.exp1` is not strengthening the hypotheses (`<(<A1 --> [left]> &/ ^left) =/> G>`, etc.) as expected. Investigate why feedback (`G.` vs `G. {0.0 0.9}`) is not revising concept tables.
   - Compare truth updates in the C logs vs. Clojure concept state after each block.
   - Ensure the target terms are stored under the correct concept/antecedent keys and that feedback trials are projecting to the right occurrence time.
2. **CLI integration** – currently you run the experiment via `clj -M -m msc2.experiments.exp1`. Consider adding argument handling to `msc2.shell/-main` so `./target/NAR exp1` mirrors the C UX.
3. **Sequence derivations** – we now derive `(A &/ ^op)` sequences, but deeper combinations (e.g., `<((A &/ B) &/ ^left) =/> G>`) are still missing. Decide whether to port the full `Cycle_ReinforceLink` behavior.
4. **Additional experiments** – experiments 2–4 still rely on the C Python scripts. Port them gradually to Clojure once Experiment 1 matches the baseline.
5. **Parity harness** – add a script to run `.nal` scripts (and experiments) through both shells and diff logs automatically for regressions.

## How to Resume Quickly

1. **Run the tests**: `clj -M:test`.
2. **Try Experiment 1**: `clj -M -m msc2.experiments.exp1` (outputs CSVs under `experiments/`).
3. **Inspect learning**:
   - After a training block, check `(:concepts state)` in `exp1/run!` (add a `println` or REPL inspect) to verify the truth of the target rules.
   - Compare with `external/msc2/experiments/exp1_truths.csv` generated by the C script.
4. **Native binary**: rebuild via `scripts/build_native.sh` and run `./target/NAR < script.nal` to ensure Graal output still matches.
5. **Micro NAL harness**: run the new simplified training scripts in `external/msc2/experiments/exp1_train_simple_*.nal` through both the C binary and the Clojure shell (e.g., `./external/msc2/MSC --shell < ...` vs `clj -M -m msc2.shell < ...`) to compare how each side revises `<(<A1 --> [left]> &/ ^left) =/> G>` under controlled positive/negative feedback.

Ping the new session with any reproducible training transcript or concept snapshot so we can dig into the missing revision. Good luck!
